
1.进程线程协程

进程是资源分配的最小单位
线程是cpu调度的最小单位，线程是进程的一个执行单元
协程是用户态的线程，比线程更加的轻量级，操作系统对其没有感知，之所以没有感知是由于协程处于线程的用户栈能感知的范围，是由用户创建的而非操作系统。

2.用户态和内核态
用户态和内核态是操作系统的两种运行状态

//用户态
不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！

//内核态
内核态可以使用计算机所有的硬件资源

3.GMP
 M (thread)    内核线程
G (goroutine)     用户协程goroutine
P (Processor)      协程调度器


线程由 CPU 调度是抢占式的
协程由用户态调度是协作式的

具体来说，协程的调度和线程切换过程如下：

当一个协程需要执行时，Go 运行时系统将其放入可运行的队列中。
如果有空闲的 M，那么该协程会被调度到空闲的 M 上执行。
如果所有 M 都处于忙碌状态，那么会创建一个新的 M，用于执行该协程。
当一个 M 中的协程执行完毕或发生阻塞时，该 M 会释放并返回给 P。
当一个 M 空闲时，它会从全局队列或其他 P 的本地队列中获取可运行的协程，并继续执行。

复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
1）work stealing 机制
当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。
2）hand off 机制
当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。
利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。
抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。
全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。



4.GC(三色标记原理+混合屏障)

4.1三色

首先把所有的对象都放到白色的集合中
从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中
遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中
循环步骤3，知道灰色集合中没有对象
步骤4结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收

4.2混合
